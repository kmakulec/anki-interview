Types of Access Modifiers	<b>public</b>: Access is not restricted.<br><b>protected</b>: Access is limited to the containing class or types derived from the containing class.<br><b>internal</b>: Access is limited to the current assembly.<br><b>protected internal</b>: Access is limited to the current assembly or types derived from the containing class.<br><b>private</b>: Access is limited to the containing type.<br><b>private protected</b>: Access is limited to the containing class or types derived from the containing class within the current assembly.<br>
Difference between Mock and Stab	<b>Stub</b> - fake objects to be able to run your test without the entire real context<br><b>Mock</b> - fake object to record the interaction of your component and verify theses interactions
What is pure function?	In computer programming, a function may be considered a pure function if both below statements about the function hold:<br><br>1. The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or between different executions of the program, nor can it depend on any external input from I/O devices.<br>2. Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices.
Difference between Entities and Value Objects	When an object can change it’s attributes but remain the same object we call it an <b>Entity</b>. An Entity is mutable because it can change it’s attributes without changing the identity of the object. The Entity object will maintain the identity because it has an id in the database.<div><br></div><div>Imagine that our application allows the person to track their current location. When the person is able to successfully connect to the internet and authenticate with our application a new Location object is created. This Location object has attributes for longitude and latitude. The Location object is a <b>Value Object</b> because we don’t care about the specific instance of the object we only care that it is a location.<br></div>
Filter types in ASP.NET Core	<b>Authorization filters</b> - run first and are used to determine whether the user is authorized for the request. Authorization filters short-circuit the pipeline if the request is not authorized.<br><br><b>Resource filters</b>:<br> - Run after authorization.<br> - OnResourceExecuting runs code before the rest of the filter pipeline. For example,&nbsp; - OnResourceExecuting runs code before model binding.<br> - OnResourceExecuted runs code after the rest of the pipeline has completed.<br><br><b>Action filters</b>:<br> - Run code immediately before and after an action method is called.<br> - Can change the arguments passed into an action.<br> - Can change the result returned from the action.<br> - Are not supported in Razor Pages.<br><br><b>Exception filters</b> - apply global policies to unhandled exceptions that occur before the response body has been written to.<br><br><b>Result filters</b> - run code immediately before and after the execution of action results. They run only when the action method has executed successfully. They are useful for logic that must surround view or formatter execution.<br>
How to implement one-to-one, one-to-many and many-to-many relationships while designing tables?	"<b>One-to-one (1:1)</b><br>A relationship is one-to-one if and only if one record from table A is related to a maximum of one record in table B.<br>To establish a one-to-one relationship, the primary key of table B (with no orphan record) must be the secondary key of table A (with orphan records).<br><br><b>One-to-many (1:M)</b><br>A relationship is one-to-many if and only if one record from table A is related to one or more records in table B. However, one record in table B cannot be related to more than one record in table A.<br>To establish a one-to-many relationship, the primary key of table A (the ""one"" table) must be the secondary key of table B (the ""many"" table).<br><br><b>Many-to-many (M:M)</b><br>A relationship is many-to-many if and only if one record from table A is related to one or more records in table B and vice-versa.<br>To establish a many-to-many relationship, create a third table called ""ClassStudentRelation"" which will have the primary keys of both table A and table B."
What is&nbsp;Value Conversions in EF Core	"Value converters allow property values to be converted when reading from or writing to the database. This conversion can be from one value to another of the same type (for example, encrypting strings) or from a value of one type to a value of another type (for example, converting enum values to and from strings in the database.)<br>[Link:&nbsp;<a href=""https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions"">https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions</a>]"
Generations in Garbage Collector in .NET	"<div>Garbage collection primarily occurs with the reclamation of short-lived  objects. To optimize the performance of the garbage collector, the  managed heap is divided into three generations, 0, 1, and 2, so it can  handle long-lived and short-lived objects separately.<b><br></b></div><b><div><b><br></b></div>Generation 0</b> - This is the youngest generation and contains short-lived objects. An example of a short-lived object is a temporary variable. Garbage collection occurs most frequently in this generation.<div><br></div><div><b>Generation 1</b> - This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.<br></div><div><br></div><div><b>Generation 2</b> - This generation contains long-lived objects. An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.<br></div><div><br></div><div>[Link:&nbsp;<a href=""https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#generations"">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals#generations</a>]</div>"
How you can check object type in C#?	"<b>typeof(T)</b> - takes a type name (which you specify at compile time).&nbsp;<div><b>.GetType()</b> - gets the runtime type of an instance.&nbsp;</div><div><b>is</b> - returns true if an instance is in the inheritance tree.</div><div><br></div><div>[Link:&nbsp;<a href=""https://stackoverflow.com/questions/983030/type-checking-typeof-gettype-or-is"">https://stackoverflow.com/questions/983030/type-checking-typeof-gettype-or-is</a>]</div>"
What do&nbsp;sealed modifier?	When applied to a class, the <u>sealed</u> modifier prevents other classes from inheriting from it.<div>You can also use the <u>sealed</u> modifier on a method or property that overrides a virtual method or property in a base class. This enables you to allow classes to derive from your class and prevent them from overriding specific virtual methods or properties.<br></div>
Difference between NUnit and XUnit	NUnit will run all the tests using the same class instance, while xUnit  will create a new instance for each test. Also, with NUnit you will use <strong>[SetUp]</strong> and <strong>[TearDown] </strong>attributes to setup and teardown common logic for your tests, while xUnit uses a parameterless&nbsp;constructor and <strong>IDisposable</strong> interface to achieve the same results.
Differences between&nbsp;First vs FirstOrDefault vs Single vs SingleOrDefault	<b>First()</b><br>1) Jeżeli jest więcej wartości spełniających warunek, to gdy użyjesz First(), to zostanie zwrócona tylko pierwsza z nich i to kończy dalsze przeszukiwanie listy.<br> 2) Jeżeli First() nie znajdzie żadnej wartości, która spełnia warunek, to zostanie rzucony wyjątek System.InvalidOperationExeption.<br><div><br></div><div><b>FirstOrDefault()</b><br>1) Jeżeli jest więcej wartości spełniających warunek, to gdy użyjesz FirstOrDefault(), to zostanie zwrócona tylko pierwsza z nich i to kończy dalsze przeszukiwanie.<br> 2) Jeżeli FirstOrDefault() nie znajdzie żadnej wartości, która spełnia warunek, to zostanie zwrócona domyślna wartość, w tym przypadku 0.<br></div><div><br></div><div><b>Single()</b><br>1) Jeżeli jest więcej wartości spełniających warunek, to przy użyciu Single() zostanie rzucony wyjątek System.InvalidOperationExeption.<br> 2) Jeżeli Single() nie znajdzie żadnej wartości, która spełnia warunek, to zostanie rzucony wyjątek System.InvalidOperationExeption.<br><br><b>SingleOrDefault()</b><br>1) Jeżeli jest więcej wartości spełniających warunek, to przy użyciu SingleOrDefault() zostanie rzucony wyjątek System.InvalidOperationExeption.<br> 2) Jeżeli SingleOrDefault () nie znajdzie żadnej wartości, która spełnia warunek, to zostanie zwrócona domyślna wartość, w tym przypadku 0.<br><br><b>W jakich sytuacjach stosować jakie wyrażenia? </b><br> 1) Jeżeli wiesz, że powinien być tylko jeden rekord (single) spełniający dany warunek i nie może być więcej niż jeden, to wtedy powinieneś użyć Single() lub SingleOrDefault() - w zależności od tego, czy oczekujesz wyjątku, czy wartości domyślnej, gdy nie będzie rekordu spełniającego warunek.<br> 2) Jeżeli interesuje Cię tylko pierwszy rekord (first) spełniający warunek i nie ma dla Ciebie znaczenie, że może być więcej rekordów spełniających ten warunek, to powinieneś użyć First() lub FirstOrDefault() - w zależności od tego, czy oczekujesz wyjątku, czy wartości domyślnej, gdy nie będzie rekordu spełniającego warunek.<br> 3) Pamiętaj też o tym, że wyrażenie First() i FirstOrDefault() jest szybsze niż Single() i SingleOrDefault(), ponieważ już po znalezieniu pierwszej szukanej wartości, dalsze przeszukiwanie kolekcji jest zakończone.<br></div>
Różnica Pomiędzy ViewData, ViewBag oraz TempData	<b>ViewData </b><br> ViewData jest to słownik (dictionary), do którego wartości odwołujemy się poprzez podanie odpowiedniego klucza, który jest string'iem. Czyli w nawiasach kwadratowych podajemy sam klucz i do tego klucza przypisujemy daną wartość, jeżeli chcemy wyświetlić wartość, to również w takich nawiasach podajemy string'a, czyli klucz, pod jakim znajduje się wartość w tym słowniku. Jako wartość słownika podajemy dowolny typ object. Jeżeli odczytujemy wartość z tego słownika, to również otrzymujemy typ object, także zazwyczaj jeszcze ViewData wymaga od nas rzutowania na inny złożony typ. Co w przypadku ViewData jest jeszcze istotne, to fakt, że jego wartość jest przechowywana tylko w obrębie jednego żądania. Jeżeli nastąpi przekierowanie, to wartość zostanie usunięta. <br><br><br><b> ViewBag</b> <br> ViewBag jest taką, można powiedzieć ulepszoną wersją ViewData. Jest takim wrapperem na ViewData, przez co jest trochę wolniejszy. Jest to typ dynamic, dzięki czemu nie musimy za każdym razem rzutować na typ oczekiwany. Podobnie jak ViewData wartość jest przechowywana tylko w obrębie jednego żądania. Jeżeli chcemy przypisać jakiś obiekt do ViewBag, to wystarczy wpisać dowolną nazwę po kropce i zrobić przypisanie, podobnie jak przypisujemy wartości do właściwości obiektów. Również w ten sam sposób możemy odczytać wartość w widoku. <br><br><br><b> TempData </b><br> Jeżeli chodzi o TempData, to wartości przypisujemy podobnie jak do ViewData, ponieważ również jest to typ słownikowy. To znaczy, po TempData umieszczamy w nawiasach kwadratowych string'a, który jest kluczem, pod którym kryje się jakaś wartość. Kluczowa różnica, jaka jest pomiędzy TempData, a ViewData jest taka, że przekierowanie nie powoduje usunięcia wartości TempData. Dane mogą być przekazywana pomiędzy żądaniami. Te dane są zapisywane w sesji.
Different between .NET Core and .NET	<div>Use .NET Core/5+ for your server application when:</div> <ul> <li>You have cross-platform needs.</li> <li>You're targeting microservices.</li> <li>You're using Docker containers.</li> <li>You need high-performance and scalable systems.</li> <li>You need side-by-side .NET versions per application. (<i>Side-by-side installation isn't possible with .NET Framework. It's a  Windows component, and only one version can exist on a machine at a  time. Each version of .NET Framework replaces the previous version. If  you install a new app that targets a later version of .NET Framework,  you might break existing apps that run on the machine, because the  previous version was replaced.</i>)</li> </ul> <div>Use .NET Framework for your server application when:</div> <ul> <li>Your app currently uses .NET Framework (recommendation is to extend instead of migrating).</li> <li>Your app uses third-party .NET libraries or NuGet packages not available for .NET Core/5+.</li> <li>Your app uses .NET Framework technologies that aren't available for .NET Core/5+. (<i>WebForms, WCF</i>)</li> <li>Your app uses a platform that doesn't support .NET Core/5+.</li></ul>
Value Type vs Reference Type	"<br><div><a href=""https://www.c-sharpcorner.com/article/stack-heap-value-type-and-reference-type-in-c-sharp/"">https://www.c-sharpcorner.com/article/stack-heap-value-type-and-reference-type-in-c-sharp/</a><br></div><div><a href=""https://www.shekhali.com/value-type-and-reference-type-in-c/"">https://www.shekhali.com/value-type-and-reference-type-in-c/</a><br></div>"
Thread safe collections	"<a href=""https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/"">https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/</a>"
